# CS300
Repository for CS300: Data Structures and Alogrithms

1. The problems being solved in Project 1 and project 2 were anlyzing the program that was needed in order to properly display, sort, and print course schedules from ABCU, including all parts of the CSV file. The analysis of pseudocode allowed me to decide which data structure would be optimal for the program. 

2. I approached the problem based on the exact requirements of what ABCU was wanting from their program. By doing this, I created pseudocode implemeting vectors, hash tables, and binary search trees. When analyzing the code and runtme analysis, we were able to see that the binary search tree was the optimal data structure to use. Data structures are key in organzing, sorting and implementing data in a program in an ethical and efficient manner. Keeping data sorted through structures like the ones I listed, one can traverse the structures in a timely manner for the desired outcome. Each structure has strengths and drawbacks in terms of runtime, size restrictions, memory usage, etc.  A knowledgable understanding of data structures is key to properly write software.

3. When going through the projects, I ran in to many roadblocks, as one would expect in applying concepts that are new to them. When writing the Pseudocode, having to remember syntax and the true meaning of the syntax in order to create a less technical explanation of the tasks or lines of code was essential. After writing the pseudocode, I had to then apply the pseudocode to actual lines of code. This seems somewhat simple in theory, but not all pseudocode translates to hard code that easily. I ran in to some issues when it came to arguments and parameters of functions being properly called in the coding. I simply referenced the text, zybooks, and a few C++ reference books I have in order to correct my issue. The errors were minimized by writing the code in iterations in order to fix errors on a small scale as they arise.

4.As I have experienced in the past when writing code or doing projects, my outlook on completing tasks or projects changes. This was my first real work with algorithms in writing code. This changed my overall approach to writing the pseudocode and brainstorming in preperation for the projects. I started to think more like a mathematician, than a developer. It boiled down to ensuring the algorithms and data structures were functional, as well as getting the desired outputs. I tried to break down my coding, writing, and problem solving in iterations as well. This seemed to help in completing the projects.


